#!/usr/bin/python2
import sys
import os

try:
    import cPickle as pickle
except:
    import pickle

from twisted.internet import defer, protocol, task
from twisted.application import internet, service
from twisted.protocols import amp
from twisted.python import util, failure
from twisted.spread import pb
import types
import re

#where did we come from?
DIRECTORY = os.path.abspath(os.path.dirname(__file__))
#cool we need this to find the config
sys.path.insert(0, DIRECTORY)
#setup our library path based on where we came from
sys.path.insert(0, os.path.join(DIRECTORY,'lib'))
#import config now!!!!
import config

#we will borrow some of droned's api
#import droned.logging
from droned.entity import Entity
from kitt.util import dictwrapper
from kitt.decorators import synchronizedDeferred
from droned.protocols.psproxy.apiwrapper import process
from droned.protocols.blaster import *
import copyright

from kitt.decorators import debugCall
log = lambda message: sys.stdout.write(str(message)+'\n')
tracker = None

###############################################################################
# Command Invocation Support
###############################################################################
class _InstanceFactory(object):
    """Used to build the process protocol."""
    def __init__(self, r, instance, deferred):
        self.reactor = r
        self.instance = instance
        self.deferred = deferred

    def __repr__(self):
        return "<ClientCreator factory: %r>" % (self.instance, )

    def buildProtocol(self, addr):
        if not self.deferred.called:
            self.deferred.callback(self.instance)
        return self.instance


class ClientCreator(protocol.ClientCreator):
    """Client Interface to launch an application"""
    def spawn(self, executable, args=(), env={}, path=None, usePTY=0,
              childFDS={0:'w',1:'r',2:'r'}, uid=None, gid=None):
        """Adding application clientCreator to ClientCreator"""
        #make sure to take care of the environment
        _env = os.environ.copy()
        _env.update(env)
        env = _env.copy()

        d = defer.Deferred()

        f = _InstanceFactory(
            self.reactor,
            self.protocolClass(
                *self.args,  
                **self.kwargs
            ),
            d
        )

        self.reactor.spawnProcess(
            f.buildProtocol(None),
            executable,
            args=args,
            env=env,
            path=path, 
            usePTY=usePTY,
            childFDs=childFDS,
            uid=uid,
            gid=gid
        )
        return d #return our deferred


class DefaultProtocol(protocol.ProcessProtocol):
    def __init__(self, *args, **kwargs):
        self.deferredResult = args[-1] #deferred result is always the last arg
        self._closeSTDIN = kwargs.get('close_stdin', True)
        self._Buffer = kwargs.get('bufferstd', False)
        self._Silence = kwargs.get('silenced', False)
        self._process = None
        self._exited = False
        self._pid = -1
        self._outbuf = ""
        self._errbuf = ""

    def connectionMade(self):
        if self._closeSTDIN:
            self.transport.closeStdin()
        self._pid = self.transport.pid
        self._process = process.Process(self.transport.pid)   
        if self._Silence: return
        #scan process table
        tracker.scheduler()
        MessageTracking.started(self._pid)

    def outReceived(self, data):
        if not self._Silence:
            MessageTracking.stdout(self._pid,data)
        if not self._Buffer: return
        self._outbuf += data

    def errReceived(self, data):
        if not self._Silence:
            MessageTracking.stderr(self._pid,data)
        if not self._Buffer: return
        self._errbuf += data

    def processExited(self, reason):
        """
        called when the process fd's are closed and process is reaped.
        """
        if self._exited: return
        self._exited = True
        process.Process.delete(self._process)
        setattr(reason.value, 'stdout', self._outbuf)
        setattr(reason.value, 'stderr', self._errbuf)
        if not self.deferredResult.called:
            self.deferredResult.errback(reason)
        if self._Silence: return
        #scan process table
        tracker.scheduler()
        MessageTracking.exited(self._pid, reason.value.exitCode)


class DroneProtocol(DefaultProtocol):
    """this is only used if we don't have systemd"""
    def __init__(self, *args, **kwargs):
        DefaultProtocol.__init__(self, *args, **kwargs)
        config.reactor.addSystemEventTrigger(
            'before', 'shutdown', self._die)

    def _die(self):
        if self.transport.pid:
            os.kill(self.transport.pid, 15)

    def outReceived(self, data):
        sys.stdout.write(data)

    def errReceived(self, data):
        sys.stderr.write(data)


def command(executable, args, **kwargs):
    """Execute commandline application via the reactor."""
    deferredResult = defer.Deferred()
    #for convience
    usePTY = kwargs.pop('usePTY', False)
    proto = kwargs.pop('protocol', DefaultProtocol)
    path = kwargs.pop('path', os.path.sep)
    env = kwargs.pop('env', os.environ.copy())
    childFDS = kwargs.pop('childFDS', {0:'w',1:'r',2:'r'})
    uid = kwargs.pop('uid', None)
    gid = kwargs.pop('gid', None)
    proto_args = tuple(kwargs.pop('proto_args', []))
    proto_args += (deferredResult,)
    #laziness hack
    def _fix_args(cmd, a):
        """I fix your commandline args b/c you are probably lazy like me"""
        first = cmd.split(os.path.sep)[-1]
        if not len(a):
            a = (first,)
            return a
        if first != a[0]:
            a = (first,) + tuple(a)
        return a
    newargs = []
    #sanitize arguments, b/c devs do silly things ... including myself
    for i in list(_fix_args(executable, args)):
        newargs += i.split(' ')
    args = tuple(newargs)

    #setup the client application to run
    app = ClientCreator(config.reactor, proto, *proto_args, **kwargs)
    deferredSpawn = app.spawn(
        executable, args, env, path, usePTY, childFDS, uid, gid)

    #If the spawn fails the protocol task fails
    deferredSpawn.addErrback(
        lambda f: deferredResult.called or
        deferredResult.errback(f)
    )
    return deferredResult


###############################################################################
# Process Watcher Support
###############################################################################
SERVICE = None


def extractData(func):
    def extract(result):
        if isinstance(result, (int,str,float,bool)):
            return result
        if isinstance(result, list):
            newList = []
            for item in result:
                newList.append(extract(item))
            return newList
        if isinstance(result, dict):
            newDict = {}
            for var, val in result.items():
                newDict[var] = extract(val)
            return newDict
        if hasattr(result, '__dict__'):
            return dict(result.__dict__)
        if hasattr(result, '_asdict'):
            return dict(result._asdict())
        return result #good luck
    def extractFailure(reason):
        return failure.Failure(
            pb.RemoteError(reason.type, reason.value, reason.printTraceback))
    def decorator(*args, **kwargs):
        d = defer.maybeDeferred(func, *args, **kwargs)
        d.addCallback(extract)
        d.addErrback(extractFailure)
        return d
    return decorator


class ProcessTracking(Entity):
    """Track processes as long as we have connections."""
    process_cache = property(lambda s: s._process_cache)
    running = property(lambda s: s._task.running)
    deferred = property(lambda s: s._deferred) 
    def __init__(self, interval):
        self._interval = interval
        self._connections = set()
        self._process_cache = {}
        self._deferred = defer.succeed({})
        self._pids = set()
        self._task = task.LoopingCall(self.scheduler)

    def start(self):
        if self.running: return
        self._task.start(self._interval)

    def stop(self):
        if not self.running: return
        self._task.stop()

    def scheduler(self):
        if not self.running:
            return self._deferred
        if self._deferred.called:
            if config.DEBUG_EVENTS:
                log('Scanning Process Table.')
            self._deferred = self._process_scanner({})
            self._deferred.addCallback(self._updateState)
            if config.DEBUG_EVENTS:
                self._deferred.addErrback(lambda x: log(x) and x or x)
            self._deferred.addErrback(lambda x: {})
        return self._deferred

    @defer.inlineCallbacks
    def _updateState(self, resultDict):
        self._process_cache = resultDict.copy()
        d = defer.Deferred()
        config.reactor.callLater(0.5, d.callback, None)
        yield d #prevent stampeeding the system
        if config.DEBUG_EVENTS:
            log('Process Table Scan Completed.')
        newset = set(resultDict.keys())
        nochange = self._pids & newset
        lost = nochange ^ self._pids
        if lost: #notify drone that we lost processes
            yield defer.DeferredList(
                map(MessageTracking.lost, lost), consumeErrors=True)
        for new in nochange ^ newset:
            try:
                yield self.process_cache[new].scan
                #notify drone that we found new processes
                yield MessageTracking.started(new)
            except:
                if config.DEBUG_EVENTS:
                    log('#' * 45)
                    log('stackstrace is from debug')
                    f = failure.Failure()
                    f.printTraceback()
                    log('#' * 45)
                newset.discard(new)
                self._process_cache.pop(new, None) 
        self._pids = newset
        d = defer.Deferred()
        config.reactor.callLater(2.5, d.callback, None)
        yield d #prevent stampeeding the system
        if config.DEBUG_EVENTS:
            log("Process Count %d" % len(self.process_cache.keys()))
        defer.returnValue(self._process_cache)

    @process.threaded
    def _process_scanner(self, results):
        for p in process.process_iter():
            try:
                results.update({p.pid: p})
            except:
                if config.DEBUG_EVENTS:
                    f = failure.Failure()
                    f.printTraceback()
        return results

###############################################################################
# DroneD Feedback mechanism.
###############################################################################
class MessageTracking(Entity):
    def __init__(self):
        self._connections = set()

    def add(self, connection):
        self._connections.add(connection)

    def discard(self, connection):
        self._connections.discard(connection)

    @defer.inlineCallbacks
    def started(self, pid, connection=None):
        state = {}
        if self._connections or connection:
            p = tracker.process_cache.get(pid, process.Process(pid))
            yield p.scan
            state = {'pid': pid}
            for i in ['create_time','cmdline','exe','name', 'original']:
                state[i] = p._cache.get(i,'')
                if isinstance(state[i], list):
                    state[i] = '\00'.join(state[i])
                elif i == 'original':
                    state[i] = str(state[i])
        if not connection and state:
            results = []
            for c in self._connections:
                d = c.callRemote(ProcessStarted, **state)
                results.append(d)
            if results:
                yield defer.DeferredList(results, consumeErrors=True)
        elif state:
            yield connection.callRemote(ProcessStarted, **state)

    def lost(self, pid):
        results = []
        for c in self._connections:
            d = c.callRemote(ProcessLost,pid=pid)
            results.append(d)
        if results:
            return defer.DeferredList(results, consumeErrors=True)
        return defer.succeed(None)

    def stdout(self, pid, data):
        results = []
        for c in self._connections:
            d = c.callRemote(ProcessStdout,pid=pid,data=data)
            results.append(d)
        if results:
            return defer.DeferredList(results, consumeErrors=True)
        return defer.succeed(None)

    def stderr(self, pid, data):
        results = []
        for c in self._connections:
            d = c.callRemote(ProcessStderr,pid=pid,data=data)
            results.append(d)
        if results:
            return defer.DeferredList(results, consumeErrors=True)
        return defer.succeed(None)

    def exited(self, pid, exitCode):
        s = process.Process._safeID(pid)
        x = process.Process._instanceMap.get(s, None)
        if x: process.Process.delete(x)
        results = []
        for c in self._connections:
            d = c.callRemote(ProcessExited,pid=pid,exitCode=exitCode)
            results.append(d)
        if results:
            return defer.DeferredList(results, consumeErrors=True)
        return defer.succeed(None)
MessageTracking = MessageTracking()


class AMPProtocol(DronedClientAMP):
    notify = MessageTracking
    def connectionMade(self):
        result = DronedClientAMP.connectionMade(self)
        self._deferred = self._afterConnect()
        self._deferred.addErrback(log)
        return result

    @defer.inlineCallbacks
    def _afterConnect(self):
        yield self.deferred #from the protocol
        yield self.requestAuthorization(config.DRONED_MASTER_KEY)
        self.notify.add(self)
        log("Updating peer %s" % (self.transport.getPeer(),))
        for system in SystemService.objects:
            yield self.callRemote(
                SystemSettings, state=pickle.dumps(system.__getstate__()))
        d = []
        for pid in tracker.process_cache.keys():
            d.append(self.notify.started(pid, connection=self))
        if d:
            yield defer.DeferredList(d, consumeErrors=True)
        self.factory.resetDelay() #reset the connection delay

    def connectionLost(self, reason):
        log("Lost peer %s" % (self.transport.getPeer(),))
        self.notify.discard(self)
        return DronedClientAMP.connectionLost(self, reason)

    @SystemCtrl.responder
    def gov_systemctl(self, service, action, argstr):
        if argstr:
            return getattr(SystemService(service), action)(*argstr.split(' '))
        return getattr(SystemService(service), action)()

    @QueryProcess.responder
    @defer.inlineCallbacks
    def get_process_info(self, method, pid, pickledArguments):
        if pid not in tracker.process_cache:
            yield tracker.scheduler()
        proc = tracker.process_cache[pid]
        func = getattr(proc, method)
        if not hasattr(func, '__call__'):
            raise AttributeError('%s is not callable' % (method,))
        func = extractData(func)
        options = pickle.loads(pickledArguments)
        result = yield func(*options['args'], **options['kwargs'])
        defer.returnValue({'pickledResponse': pickle.dumps(result)})

    @Command.responder
    def gov_command(self, pickledArguments):
        options = pickle.loads(pickledArguments)
        if not 'uid' in options['kwargs']:
            options['kwargs']['uid'] = config.running_uid
        if not 'gid' in options['kwargs']:
            options['kwargs']['gid'] = config.running_gid
        d = command(options['exec'], *options['args'], **options['kwargs'])
        d.addBoth(self._gov_processResult)
        return d

    def _gov_processResult(self, result):
        exitCode = result.value.exitCode
        description = result.value.message
        try:
            sig = KNOWN_SIGNALS.get(result.value.signal, str(None))
        except:
            sig = 0
        status = result.value.status or 0
        return {
            'code': exitCode, 
            'description': description.strip(),
            'status': status,
            'signal': str(sig)
        }


class SystemService(Entity):
    """Encapsulate Services."""
    def __init__(self, name):
        self.name = name
        self.data = {'Names': name}

    def __getstate__(self):
        return {
            'name': self.name,
            'methods': {
                'start':   [(), self.start.__doc__],
                'stop':    [(), self.stop.__doc__],
                'status':  [(), self.status.__doc__],
                'restart': [(), self.restart.__doc__],
                'enable':  [(), self.enable.__doc__],
                'disable': [(), self.disable.__doc__],
                'show':    [(), self.show.__doc__],
                'value':   [('key',), self.value.__doc__]
            }
        }

    def value(self, key):
        """Get systemd value by key"""
        return {
            'description': str(self.data.get(key, None)).strip(),
            'code': 0,
            'status': 0,
            'signal': '0'
        }

    @defer.inlineCallbacks
    def enable(self):
        """enable service."""
        yield self(config.system.enable(self.name))
        result = yield self.status()
        defer.returnValue(result)

    @defer.inlineCallbacks
    def disable(self):
        """disable service."""
        yield self(config.system.disable(self.name))
        result = yield self.status()
        defer.returnValue(result)

    @defer.inlineCallbacks
    def restart(self):
        """restart service."""
        pid = int(self.data.get('MainPID', 0))
        if pid:
            MessageTracking.exited(pid, 0)
        yield self(config.system.restart(self.name))
        result = yield self.status()
        pid = int(self.data.get('MainPID', 0))
        if pid and not result['code']:
            MessageTracking.started(pid)
        defer.returnValue(result)

    @defer.inlineCallbacks
    def show(self):
        """show settings."""
        result = yield self(config.system.show(self.name))
        result.pop('stderr')
        result['description'] = result.pop('stdout')
        for line in result['description'].split('\n'):
            if not line: continue
            if config.system.systemd:
                data = line.split('=',1)
                self.data[data[0]] = data[1]
                continue
            m = config.system.show_regex.search(line)
            if not m: continue
            for var, val in m.groupdict().items():
                if not val:
                    self.data.pop(var, None)
                    continue
                self.data[var.replace('2','')] = val
        if not config.system.systemd:
            result['description'] = '\n'.join("%s=%s" % (var,str(val)) for var, val in self.data.items())
        tracker.scheduler()
        defer.returnValue(result)

    @defer.inlineCallbacks
    def start(self):
        """start service."""
        opid = int(self.data.get('MainPID', 0))
        r = yield self(config.system.start(self.name))
        result = yield self.status()
        pid = int(self.data.get('MainPID', 0))
        if pid and not r['code'] or pid != opid and pid:
            MessageTracking.started(pid)
        yield self.show()
        defer.returnValue(result)

    @defer.inlineCallbacks
    def stop(self):
        """stop service."""
        pid = int(self.data.get('MainPID', 0))
        r = yield self(config.system.stop(self.name))
        result = yield self.status()
        if pid and not r['code']:
            MessageTracking.exited(pid, r['code'])
        yield self.show()
        defer.returnValue(result)

    @defer.inlineCallbacks
    def status(self):
        """show status."""
        result = yield self(config.system.status(self.name))
        result.pop('stderr')
        result['description'] = result.pop('stdout').strip()
        yield self.show()
        defer.returnValue(result)

    @defer.inlineCallbacks
    def __call__(self, args):
        result = {}
        try:
            result = yield command(args[0], args[1],
                bufferstd=True, silenced=True)
        except:
            f = failure.Failure()
            status = f.value.status or 0
            try:
                sig = f.value.signal
            except:
                sig = 0
            result = {
                'code': f.value.exitCode,
                'stdout': f.value.stdout,
                'stderr': f.value.stderr,
                'signal': str(sig),
                'status': status
            }
        defer.returnValue(result)
            

class SystemManager(internet.TCPClient):
    def __init__(self, *args, **kwargs):
        cmd, arg = config.system.list()
        self._deferred = defer.Deferred()
        d = command(cmd, arg, bufferstd=True)
        d.addErrback(self._process_units)
        internet.TCPClient.__init__(self, *args, **kwargs)

    @defer.inlineCallbacks
    def _process_units(self, reason):
        log("Checking for Service Information.")
        for line in reason.value.stdout.split('\n'):
            if not line: continue
            line = line.replace('\t',' ')
            try:
                yield SystemService(line.split(' ')[0]).show()
            except: pass
        tracker.start()
        running = tracker.running
        while not running:
            running = yield defer.maybeDeferred(lambda: tracker.running)
        yield tracker.deferred
        while not len(tracker.process_cache.keys()):
            yield tracker.scheduler()
        self._deferred.callback(None)
        log("Finished Checking System.")

    def startService(self):
        if self._deferred.called:
            return internet.TCPClient.startService(self)
        self._deferred.addBoth(
            lambda x: internet.TCPClient.startService(self))
        return self._deferred

    @defer.inlineCallbacks
    def stopService(self):
        tracker.stop()
        yield tracker.deferred
        yield defer.maybeDeferred(internet.TCPClient.stopService, self)

class Drone(service.Service):
    """This is only used if we don't have systemd"""
    comm = os.path.join(DIRECTORY,'drone')
    args = sys.argv[1:]
    deferred = defer.succeed(None)

    @defer.inlineCallbacks
    def run(self):
        while self.running:
            try: #make sure drone command process stays running.
                yield command(self.comm, self.args, protocol=DroneProtocol)
            except: pass

    def startService(self):
        if self.running: return
        service.Service.startService(self)
        self.deferred = self.run()

    def stopService(self):
        service.Service.stopService(self)
        return self.deferred 

class Reconnector(protocol.ReconnectingClientFactory, object):
      noisy = property(lambda s: config.DEBUG_EVENTS)

      def buildProtocol(self, *args, **kwargs):
          """make sure we can reset the connection delay."""
          proto = protocol.ReconnectingClientFactory.buildProtocol(
              self, *args, **kwargs)
          proto.factory = self
          return proto

###############################################################################
# Main Setup
###############################################################################
def main():
    from kitt.daemon import owndir

    #take ownership of droned's directories.
    for var, val in config.items():
        if not str(val).startswith(os.path.sep): continue
        if not str(var).endswith('DIR'): continue
        owndir(config.DRONED_USER, val)

    #use syslog facility to manage the logs
    if not config.system.systemd and not config.DEBUG_EVENTS:
        pid = os.fork() #first fork
        if pid > 0: sys.exit(0)
        os.chdir(os.path.sep)
        os.setsid()
        os.umask(0)
        pid = os.fork() #double fork
        if pid > 0: sys.exit(0)
        sys.stdout.flush()
        sys.stderr.flush()
        si = open('/dev/null', 'r')
        so = open('/dev/null', 'a+')
        se = open('/dev/null', 'a+')
        os.dup2(si.fileno(), sys.stdin.fileno())
        os.dup2(so.fileno(), sys.stdout.fileno())
        os.dup2(se.fileno(), sys.stderr.fileno())
        #setup logger
        pid = str(os.getpid())
        from twisted.python import syslog
        syslog.startLogging(prefix='droned[%s]' % (pid,))
        pidfile = os.environ.get(
            'PIDFILE', os.path.join(config.DRONED_HOMEDIR, 'droned.pid'))
        pidfile = open(pidfile, 'w')
        pidfile.write(pid)
        pidfile.close()
    elif config.system.systemd: #systemd will manage this for us
        import droned.logging
        droned.logging.logToStdout(timestamp=config.DEBUG_EVENTS)
    import grp
    import pwd
    # Get the uid/gid from the name
    config.running_uid = pwd.getpwnam(config.DRONED_USER).pw_uid
    config.running_gid = grp.getgrnam(config.DRONED_GROUP).gr_gid

    tracker = globals()['tracker'] = ProcessTracking(60.0)

    application = service.Application('droned')
    # send messages to our command and control server
    factory = Reconnector()
    factory.protocol = AMPProtocol
    if isinstance(config.DRONED_PORT, types.StringTypes):
        config.DRONED_PORT = int(config.DRONED_PORT.split(':').pop())
    service.IServiceCollection(application).addService(
        SystemManager("127.0.0.1", config.DRONED_PORT ,factory))
    if not config.system.systemd: #supervise our command processor
        service.IServiceCollection(application).addService(Drone())
    config.reactor.callWhenRunning(
        service.IService(application).startService
    )

    config.reactor.addSystemEventTrigger('before', 'shutdown',
        service.IService(application).stopService
    )
    log("Entering Event Loop.")
    config.reactor.run()
    log('Droned Exiting.')
    #post clean up.
    pidfile = os.environ.get(
        'PIDFILE', os.path.join(config.DRONED_HOMEDIR, 'droned.pid'))
    if os.path.exists(pidfile): os.remove(pidfile)
    sys.exit(0)

if __name__ == '__main__': main()
